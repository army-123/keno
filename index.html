<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ziii game</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#0b0b0b; --gold:#d8a800; --muted:#9a9a9a;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial;
  background: radial-gradient(circle at 10% 10%, rgba(216,168,0,0.04), transparent 15%), linear-gradient(180deg,#050505 0%, #0b0b0b 100%);
  color:#fff;
  -webkit-font-smoothing:antialiased;
  padding:24px;
  text-align:center;
}

/* Header */
header h1{ font-size:34px; color:var(--gold); margin:6px 0 18px 0; text-transform:lowercase; }

/* Wallet */
#wallet { color:#00f2ff; font-weight:700; margin-bottom:14px; }

/* Join buttons */
#joinContainer { margin: 14px 0; display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
.joinBtn{
  background:linear-gradient(180deg,var(--gold), #b27f00);
  color:#000; border:none; padding:12px 18px; border-radius:10px; font-weight:800; cursor:pointer;
  min-width:160px;
  box-shadow:0 8px 26px rgba(178,127,0,0.18);
}

/* Lobby panel */
.lobby-panel{ max-width:1100px; margin: 18px auto; padding:16px; background:rgba(255,255,255,0.02); border-radius:12px; display:flex; gap:18px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
.players-list{ width:52%; text-align:left; }
.controls{ width:44%; text-align:left; }

/* Player row */
.player-row{ display:flex; justify-content:space-between; padding:10px 12px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); margin-bottom:8px; border:1px solid rgba(255,255,255,0.02); }
.status-pill{ padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; color:#fff; }
.submitted{ background:#0fa04a; }
.notready{ background:#444; }

/* grid */
.grid-wrap{ margin-top:22px; }
.grid{ display:grid; grid-template-columns:repeat(10,1fr); gap:10px; max-width:1000px; margin:12px auto; }
.num{ padding:12px; border-radius:8px; background:#111; border:2px solid rgba(216,168,0,0.05); cursor:pointer; font-weight:700; color:#fff; user-select:none; }
.num:hover{ transform:translateY(-4px); transition:all .12s; }
.num.selected{ border-color:var(--gold); color:var(--gold); box-shadow:0 8px 26px rgba(216,168,0,0.06); }

/* waiting glow */
#waiting { display:none; margin-top:10px; font-weight:800; color:var(--gold); text-shadow:0 0 12px rgba(216,168,0,0.25); animation:glow 1.1s infinite alternate; }
@keyframes glow{ from{ text-shadow:0 0 8px rgba(216,168,0,0.12)} to{ text-shadow:0 0 22px rgba(255,230,160,0.22)} }

/* countdown */
#countdown{ margin-top:12px; font-size:28px; color:#00eaff; font-weight:800; display:none; }

/* results modal */
.modal-backdrop{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.75)); z-index:99; }
.modal{ width:92%; max-width:720px; background:#0f0f0f; padding:22px; border-radius:12px; box-shadow:0 20px 60px rgba(0,0,0,0.6); color:#fff; text-align:center; }
.drawn{ margin:12px 0; font-weight:700; color:#fff; }
.winner-row{ margin:8px 0; padding:10px; border-radius:8px; background:rgba(255,255,255,0.02); }

/* responsive */
@media(max-width:880px){
  .players-list,.controls{ width:100%; }
  .grid{ grid-template-columns:repeat(6,1fr); }
  #joinContainer{ flex-direction:column; align-items:center; }
}
</style>
</head>

<body>
<header class="container">
  <h1>ziii game</h1>
  <div id="wallet">Wallet: —</div>
</header>

<!-- Join buttons visible first -->
<div id="joinContainer">
  <button class="joinBtn" data-amt="10" onclick="selectEntry(10)">Join with 10</button>
  <button class="joinBtn" data-amt="20" onclick="selectEntry(20)">Join with 20</button>
  <button class="joinBtn" data-amt="50" onclick="selectEntry(50)">Join with 50</button>
</div>

<!-- Lobby panel -->
<div class="lobby-panel" id="lobbyPanel" style="display:none;">
  <div class="players-list">
    <h2>Public Lobby</h2>
    <div id="PlayersList">Loading players...</div>
    <div style="margin-top:12px;">
      <button class="joinBtn" id="leaveBtn" style="background:transparent;color:#fff;border:1px solid rgba(255,255,255,0.06);">Leave Lobby</button>
      <button class="joinBtn" id="submitBtn" style="min-width:140px; background:linear-gradient(180deg,var(--gold), #b27f00); color:#000;">Submit 5 Numbers</button>
    </div>
  </div>

  <div class="controls">
    <h3 style="margin-top:0;color:var(--gold)">Lobby Status</h3>
    <div style="color:var(--muted);margin-bottom:6px">Room: <strong id="roomLabel">—</strong></div>
    <div style="color:var(--muted);margin-bottom:6px">Players: <strong id="playerCount">—</strong></div>
    <div style="color:var(--muted);margin-bottom:6px">Status: <strong id="status">waiting</strong></div>
    <div style="color:var(--muted);margin-bottom:6px">Countdown: <strong id="countdownLabel">—</strong></div>
    <div style="color:var(--muted);margin-bottom:6px">Host: <strong id="hostLabel">—</strong></div>
    <div id="waiting" style="display:none;">✨ Waiting for players… ✨</div>
    <div id="countdown" style="display:none;"></div>
  </div>
</div>

<!-- Number grid (hidden until entry selected) -->
<div class="grid-wrap" id="gridWrap" style="display:none;">
  <div class="grid" id="grid"></div>
</div>

<!-- Results modal -->
<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal">
    <h2>Round Results</h2>
    <div class="drawn" id="drawnNumbers">—</div>
    <div id="winnersBox"></div>
    <div style="margin-top:18px;">
      <button class="joinBtn" onclick="closeModal()">OK</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
/* ========================
   CONFIG
   ======================== */
const SUPABASE_URL = "https://vdhuexwgplylprgpddoq.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZkaHVleHdncGx5bHByZ3BkZG9xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ1NzI3MzgsImV4cCI6MjA4MDE0ODczOH0.oAtftTGawGDSTSpvzZQY_TCjn494tGQ2dn6nGwlzYfc";

const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

/* ========================
   App state
   ======================== */
let username = localStorage.getItem('ziii_user') || ("user_" + Math.floor(Math.random()*900000+100000));
localStorage.setItem('ziii_user', username);

let entryAmount = Number(localStorage.getItem('ziii_amount')) || null; // 10/20/50 or null
let myPlayerId = null;
let isHost = false;
let countdownRunning = false;

/* ========================
   UI refs
   ======================== */
const walletEl = document.getElementById('wallet');
const joinContainer = document.getElementById('joinContainer');
const lobbyPanel = document.getElementById('lobbyPanel');
const playersListEl = document.getElementById('PlayersList');
const roomLabel = document.getElementById('roomLabel');
const playerCountEl = document.getElementById('playerCount');
const statusEl = document.getElementById('status');
const countdownLabel = document.getElementById('countdownLabel');
const hostLabel = document.getElementById('hostLabel');
const waitingEl = document.getElementById('waiting');
const countdownEl = document.getElementById('countdown');
const gridWrap = document.getElementById('gridWrap');
const gridEl = document.getElementById('grid');
const modalBackdrop = document.getElementById('modalBackdrop');
const drawnNumbersEl = document.getElementById('drawnNumbers');
const winnersBox = document.getElementById('winnersBox');
const submitBtn = document.getElementById('submitBtn');
const leaveBtn = document.getElementById('leaveBtn');

/* ========================
   Helpers
   ======================== */
function nowIso(){ return new Date().toISOString(); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/* ========================
   Ensure player row exists (players table should have columns: username, room, picks jsonb, ready boolean, wallet int, joined_at timestamptz)
   ======================== */
async function ensurePlayerRow() {
  // check existing row in players with same username and room
  if (!entryAmount) return;
  const { data } = await supabase
    .from('players')
    .select('*')
    .eq('username', username)
    .eq('room', entryAmount)
    .maybeSingle();

  if (data) {
    myPlayerId = data.id;
    return;
  }

  // If player exists in other room(s), delete them there and create for this room
  try { await supabase.from('players').delete().eq('username', username); } catch(e){}

  const { data: inserted } = await supabase.from('players').insert([{
    username, room: entryAmount, picks: [], ready: false, wallet: 200
  }]).select().single();

  myPlayerId = inserted.id;
}

/* ========================
   Wallet display (reads players row)
   ======================== */
async function loadWallet() {
  const { data } = await supabase.from('players').select('wallet').eq('username', username).eq('room', entryAmount).maybeSingle();
  walletEl.innerText = 'Wallet: ' + (data?.wallet ?? 0) + ' coins';
}

/* ========================
   Join entry selection (called when user clicks Join with X)
   ======================== */
async function selectEntry(amount) {
  entryAmount = amount;
  localStorage.setItem('ziii_amount', amount);

  // Deduct entry cost from wallet or create player if not exists
  // If player exists, ensure room match and deduct coins.
  // We keep it simple: upsert players row for this room with wallet deduction if necessary.

  // Load any existing player row (any room)
  const { data: existing } = await supabase.from('players').select('*').eq('username', username).maybeSingle();

  if (existing && existing.wallet !== undefined) {
    if (existing.wallet < amount) {
      alert('Not enough coins in wallet!');
      return;
    }
  }

  // Remove other rows for this username so user is only in one room
  try { await supabase.from('players').delete().eq('username', username); } catch(e){}

  // Create new player row for this room with deducted wallet
  const walletStart = (existing?.wallet ?? 200) - amount;
  const { data: inserted } = await supabase.from('players').insert([{
    username, room: amount, picks: [], ready: false, wallet: walletStart
  }]).select().single();

  myPlayerId = inserted.id;

  // hide join buttons, show lobby + grid
  joinContainer.style.display = 'none';
  lobbyPanel.style.display = 'flex';
  gridWrap.style.display = 'block';
  roomLabel.innerText = entryAmount;

  // build grid and load realtime
  buildGrid();
  await loadWallet();
  await setupRealtimeForRoom(entryAmount);
  refreshUI(); // initial UI update
}

/* ========================
   Build grid 1..100 (hidden until choose entry)
   ======================== */
function buildGrid(){
  gridEl.innerHTML = '';
  for (let i=1;i<=100;i++){
    const d = document.createElement('div');
    d.className = 'num';
    d.innerText = i;
    d.dataset.val = i;
    d.onclick = () => {
      if (!d.classList.contains('selected') && document.querySelectorAll('.num.selected').length >= 5) return;
      d.classList.toggle('selected');
    };
    gridEl.appendChild(d);
  }
  // show submit button event
  submitBtn.onclick = submitPicks;
  leaveBtn.onclick = leaveLobby;
}

/* ========================
   Submit picks
   ======================== */
async function submitPicks(){
  // gather selected numbers
  const picks = [...document.querySelectorAll('.num.selected')].map(n => Number(n.dataset.val));
  if (picks.length !== 5) return alert('Pick exactly 5 numbers');

  // Update player row for this room
  try {
    await supabase.from('players').update({ picks: picks, ready: true, joined_at: nowIso() }).eq('id', myPlayerId);
  } catch(e){ console.error('submit error', e); alert('Submit failed'); return; }

  waitingEl.style.display = 'block';
  statusEl.innerText = 'waiting';
}

/* ========================
   Leave lobby
   ======================== */
async function leaveLobby(){
  try { await supabase.from('players').delete().eq('id', myPlayerId); } catch(e){}
  // reset UI
  localStorage.removeItem('ziii_amount');
  location.reload();
}

/* ========================
   Setup realtime listeners for this room
   ======================== */
let playersChannel = null;
let gameStateChannel = null;
let hostTickRunning = false;

async function setupRealtimeForRoom(room) {
  // unsubscribe if existing
  if (playersChannel) { try { await playersChannel.unsubscribe(); } catch(e){} playersChannel=null; }
  if (gameStateChannel) { try { await gameStateChannel.unsubscribe(); } catch(e){} gameStateChannel=null; }

  // players table changes for this room
  playersChannel = supabase.channel('players_room_' + room)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'players', filter: `room=eq.${room}` }, payload => {
      refreshUI();
    })
    .subscribe();

  // game_state changes for this room
  gameStateChannel = supabase.channel('game_state_room_' + room)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state', filter: `entry=eq.${room}` }, payload => {
      refreshUI();
    })
    .subscribe();

  // ensure game_state row exists for this room
  const { data } = await supabase.from('game_state').select('*').eq('entry', room).maybeSingle();
  if (!data) {
    await supabase.from('game_state').insert([{ entry: room, players: [], numbers: [], status: 'waiting', countdown: 60, min_players: 2 }]);
  }
}

/* ========================
   Refresh UI: players + state
   ======================== */
async function refreshUI(){
  if (!entryAmount) return;

  // fetch players in room (ordered by joined_at then id)
  const { data: players } = await supabase.from('players').select('*').eq('room', entryAmount).order('joined_at', { ascending: true }).order('id', { ascending: true });

  renderPlayers(players);

  // fetch game_state for room
  const { data: gs } = await supabase.from('game_state').select('*').eq('entry', entryAmount).maybeSingle();
  renderState(gs, players);
  await loadWallet();
}

/* ========================
   Render players list
   ======================== */
function renderPlayers(players){
  playersListEl.innerHTML = '';
  if (!players || players.length === 0) {
    playersListEl.innerHTML = '<div style="color:var(--muted)">No players yet</div>';
    playerCountEl.innerText = '0';
    hostLabel.innerText = '—';
    return;
  }

  // sort stable: joined_at then id
  players.sort((a,b) => {
    const ta = a.joined_at ? new Date(a.joined_at).getTime() : 0;
    const tb = b.joined_at ? new Date(b.joined_at).getTime() : 0;
    if (ta !== tb) return ta - tb;
    return (a.id || 0) - (b.id || 0);
  });

  players.forEach(p => {
    const div = document.createElement('div');
    div.className = 'player-row';
    div.innerHTML = `<div style="text-align:left"><strong>${p.username}</strong><div style="color:var(--muted);font-size:12px">amt: ${p.room||'-'}</div></div>
                     <div><span class="status-pill ${p.ready?'submitted':'notready'}">${p.ready? 'SUBMITTED':'Not ready'}</span></div>`;
    playersListEl.appendChild(div);
  });

  playerCountEl.innerText = players.length;
  const host = players[0].username;
  hostLabel.innerText = host;
  isHost = (host === username);
}

/* ========================
   Render game_state status + handle countdown start/stop
   ======================== */
async function renderState(gs, players){
  if (!gs) return;

  statusEl.innerText = gs.status || 'waiting';
  countdownLabel.innerText = (typeof gs.countdown !== 'undefined' && gs.countdown !== null) ? gs.countdown : '—';

  // Show waiting element when we're waiting and we submitted
  const me = players?.find(p => p.username === username);
  if (gs.status === 'waiting') {
    // If there are >= min_players submitted (ready true), host should set timestamp -> start countdown
    const readyPlayers = (players || []).filter(p => p.ready).length;
    const minPlayers = gs.min_players || 2;

    // Show glowing waiting if we've submitted but not enough players OR status waiting
    if (me && me.ready && readyPlayers < minPlayers) {
      waitingEl.style.display = 'block';
    } else if (gs.status === 'waiting') {
      waitingEl.style.display = 'none';
    }

    if (readyPlayers >= minPlayers) {
      // ensure round_started_at exists (host responsibility)
      if (!gs.round_started_at && isHost) {
        // host starts the countdown using timestamp method
        try {
          await supabase.from('game_state').update({
            status: 'countdown',
            countdown: 60,
            round_started_at: nowIso()
          }).eq('entry', entryAmount);
        } catch(e){ console.warn('host start error', e); }
      }
    }
  }

  // If status is countdown -> display countdown computed by clients from round_started_at
  if (gs.status === 'countdown' && gs.round_started_at) {
    waitingEl.style.display = 'none';
    countdownEl.style.display = 'block';
    // compute remaining
    const started = new Date(gs.round_started_at).getTime();
    const elapsed = Math.floor((Date.now() - started) / 1000);
    const remaining = Math.max(0, 60 - elapsed);
    countdownEl.innerText = remaining + 's';
    // show label in controls
    countdownLabel.innerText = remaining + 's';

    // host tick loop (only one host will run heavy ops)
    if (isHost && !hostTickRunning) {
      hostTickRunning = true;
      hostTickLoop();
    }
  } else {
    countdownEl.style.display = 'none';
    countdownLabel.innerText = (gs.countdown == null ? '—' : gs.countdown);
  }

  // If status finished -> show results modal
  if (gs.status === 'finished') {
    showResultsModal(gs);
  }
}

/* ========================
   Host tick loop: updates countdown and triggers draw at 0
   ======================== */
let hostTickRunning = false;

async function hostTickLoop() {
  hostTickRunning = true;
  try {
    const { data: gs } = await supabase.from('game_state').select('*').eq('entry', entryAmount).maybeSingle();
    if (!gs || gs.status !== 'countdown' || !gs.round_started_at) {
      hostTickRunning = false; return;
    }

    const started = new Date(gs.round_started_at).getTime();
    const elapsed = Math.floor((Date.now() - started) / 1000);
    const remaining = Math.max(0, 60 - elapsed);

    // Update countdown if changed
    if (gs.countdown !== remaining) {
      try {
        await supabase.from('game_state').update({ countdown: remaining }).eq('entry', entryAmount);
      } catch(e){}
    }

    if (remaining <= 0) {
      // draw numbers and finish the round (only host)
      await performDrawAndFinish(gs);
      hostTickRunning = false;
      return;
    }

    // continue
    setTimeout(hostTickLoop, 1000);
  } catch(err) {
    console.error('hostTickLoop error', err);
    hostTickRunning = false;
  }
}

/* ========================
   perform draw, compute winners, update wallets
   ======================== */
async function performDrawAndFinish(stateRow) {
  try {
    // Prevent double-draw: re-fetch state
    const { data: fresh } = await supabase.from('game_state').select('*').eq('entry', entryAmount).maybeSingle();
    if (!fresh) return;
    if (Array.isArray(fresh.drawn_numbers) && fresh.drawn_numbers.length > 0) {
      console.log('already drawn');
      return;
    }

    // 1) Draw 20 unique numbers (1..100)
    const drawn = [];
    while (drawn.length < 20) {
      const n = Math.floor(Math.random() * 100) + 1;
      if (!drawn.includes(n)) drawn.push(n);
    }

    // 2) Fetch players in this room who submitted picks
    const { data: players } = await supabase.from('players').select('*').eq('room', entryAmount);

    // 3) Calculate winners and update wallets & leaderboard
    const winners = [];
    for (const p of players || []) {
      const picks = Array.isArray(p.picks) ? p.picks : [];
      const hits = picks.filter(x => drawn.includes(x)).length;
      let reward = 0;
      if (hits === 3) reward = 10;
      if (hits === 4) reward = 20;
      if (hits >= 5) reward = 50;

      if (reward > 0) {
        // Try to update player's wallet atomically
        try {
          await supabase.from('players').update({ wallet: (p.wallet || 0) + reward }).eq('id', p.id);
        } catch(e){ console.warn('wallet update error', e); }
      }

      if (hits > 0) {
        // write leaderboard row (non-blocking)
        try { await supabase.from('leaderboard').insert([{ username: p.username, score: hits * 10 }]); } catch(e){}
      }

      if (hits > 0) winners.push({ username: p.username, matches: hits });
    }

    // 4) Persist drawn numbers and winners into game_state and mark finished
    await supabase.from('game_state').update({
      status: 'finished',
      drawn_numbers: drawn,
      round_winners: winners,
      round_finished_at: nowIso(),
      countdown: 0
    }).eq('entry', entryAmount);

    // 5) After a pause, reset the round (clear ready flags and drawn_numbers)
    setTimeout(async () => {
      try {
        await supabase.from('players').update({ ready: false, picks: [] }).eq('room', entryAmount);
        await supabase.from('game_state').update({
          status: 'waiting',
          countdown: 60,
          round_started_at: null,
          drawn_numbers: [],
          round_winners: []
        }).eq('entry', entryAmount);
      } catch(e){ console.warn('reset failed', e); }
    }, 12000);

  } catch(err) {
    console.error('performDrawAndFinish error', err);
  }
}

/* ========================
   Show Results Modal
   ======================== */
function showResultsModal(gs) {
  drawnNumbersEl.innerText = (gs.drawn_numbers || []).join(', ') || '—';
  winnersBox.innerHTML = '';
  const winners = gs.round_winners || [];
  if (!winners || winners.length === 0) {
    winnersBox.innerHTML = '<div class="winner-row">No winners this round</div>';
  } else {
    winners.forEach(w => {
      winnersBox.innerHTML += `<div class="winner-row">${w.username} — matches: ${w.matches}</div>`;
    });
  }
  modalBackdrop.style.display = 'flex';
}

/* ========================
   Close modal
   ======================== */
function closeModal(){
  modalBackdrop.style.display = 'none';
}

/* ========================
   Initial boot: if user already had entryAmount (auto-join)
   ======================== */
(async function boot() {
  try {
    if (entryAmount) {
      // hide join, show UI
      joinContainer.style.display = 'none';
      lobbyPanel.style.display = 'flex';
      gridWrap.style.display = 'block';
      roomLabel.innerText = entryAmount;

      // ensure player row exists and start realtime
      await ensurePlayerRow();
      await loadWallet();
      await setupRealtimeForRoom(entryAmount);
      refreshUI();
    } else {
      // show join buttons (already shown)
      joinContainer.style.display = 'flex';
      lobbyPanel.style.display = 'none';
      gridWrap.style.display = 'none';
    }
  } catch(e){ console.error('boot error', e); }
})();

/* ========================
   Realtime fallback: watch game_entries table in case players insert into that (compat)
   ======================== */
/* Not needed — main channels are set up in setupRealtimeForRoom */

/* ========================
   END
   ======================== */
</script>
</body>
</html>
